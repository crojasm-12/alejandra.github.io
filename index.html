<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <!-- Ensure proper viewport scaling for mobile -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Multiplication Catch Game</title>
    <style>
        /* Basic Reset & No Scrollbars */
        html, body {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden; /* Crucial: Prevent scrollbars */
            font-family: 'Arial', sans-serif; /* Simple, readable font */
            /* Prevent pull-to-refresh and other touch gestures */
            overscroll-behavior: none;
        }

        /* Space Background */
        body {
            background-color: #0a0a1a; /* Dark base for space */
            background-image:
                radial-gradient(circle at 20% 30%, rgba(173, 216, 230, 0.1) 0%, transparent 30%), /* Light Blue Nebula */
                radial-gradient(circle at 80% 70%, rgba(221, 160, 221, 0.1) 0%, transparent 30%), /* Plum Nebula */
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.05) 0%, transparent 5%), /* Faint central glow */
                /* Tiny Stars using multiple small radial gradients */
                radial-gradient(circle at 10% 10%, white 0.5px, transparent 1px),
                radial-gradient(circle at 50% 20%, white 0.5px, transparent 1px),
                radial-gradient(circle at 90% 30%, white 0.5px, transparent 1px),
                radial-gradient(circle at 30% 50%, white 0.5px, transparent 1px),
                radial-gradient(circle at 70% 60%, white 0.5px, transparent 1px),
                radial-gradient(circle at 15% 80%, white 0.5px, transparent 1px),
                radial-gradient(circle at 60% 90%, white 0.5px, transparent 1px),
                radial-gradient(circle at 85% 55%, white 0.5px, transparent 1px);
            background-size: cover;
            background-attachment: fixed; /* Keeps background static */
        }

        /* Score and Level Display */
        #scoreDisplay, #levelDisplay {
            position: absolute;
            padding: 10px 15px;
            border-radius: 8px;
            font-size: 1.5em;
            font-weight: bold;
            color: #333; /* Dark text for contrast on pastel */
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5);
            z-index: 10; /* Ensure they are above the canvas */
            /* Prevent text selection on UI elements */
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }

        #scoreDisplay {
            top: 10px;
            left: 10px;
            background-color: #A0E7E5; /* Pastel Cyan */
        }

        #levelDisplay {
            top: 10px;
            right: 10px;
            background-color: #FFAEBC; /* Pastel Pink */
        }

        /* Canvas Styling */
        #gameCanvas {
            display: block; /* Removes potential extra space below */
            position: absolute;
            top: 0;
            left: 0;
            /* Width and height will be set by JavaScript */
            z-index: 1; /* Below UI elements */
        }
    </style>
</head>
<body>
    <!-- UI Elements -->
    <div id="scoreDisplay">Score: 0</div>
    <div id="levelDisplay">Level: 1</div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <script>
        // Wait for the DOM to be fully loaded
        document.addEventListener('DOMContentLoaded', () => {
            // --- Canvas Setup ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            let canvasWidth = window.innerWidth;
            let canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // --- UI Elements ---
            const scoreElement = document.getElementById('scoreDisplay');
            const levelElement = document.getElementById('levelDisplay');

            // --- Game State ---
            let score = 0;
            let level = 1;
            const maxLevel = 10;
            let currentProblem = { factor1: 1, factor2: 1 };
            let correctAnswer = 1;
            let gameActive = true;
            let feedbackTimer = 0;
            let feedbackType = null;

            // --- Pastel Colors ---
            const pastelColors = [
                '#A0E7E5', '#B4F8C8', '#FBE7C6', '#FFAEBC',
                '#FFDAC1', '#CDB4DB', '#FFFACD', '#ADD8E6',
            ];

            function getRandomPastelColor() {
                return pastelColors[Math.floor(Math.random() * pastelColors.length)];
            }

            // --- Player Controlled Rectangle ---
            const originalBaseWidth = 150;
            const originalBaseHeight = 100;
            const playerRect = {
                baseWidth: originalBaseWidth * 0.8,   // 120
                baseHeight: originalBaseHeight * 0.8,  // 80
                x: canvasWidth / 2 - (originalBaseWidth * 0.8) / 2,
                y: canvasHeight - (originalBaseHeight * 0.8) - 40,
                width: originalBaseWidth * 0.8,
                height: originalBaseHeight * 0.8,
                speed: 8,
                dx: 0,
                color: getRandomPastelColor(),
                gridLineWidth: 1,
                gridLineColor: 'rgba(50, 50, 50, 0.5)',
                labelFont: 'bold 14px Arial',
                labelColor: 'white'
            };

            // --- Falling Squares ---
            const fallingSquares = [];
            const squareSize = 60;
            const baseFallSpeed = 1;
            const speedIncrement = 0.3;
             // UPDATE 1 & 2: Define required space for placement
            const minGapBetweenSquares = playerRect.baseWidth; // Ensure catcher fits between
            const requiredSlotWidth = squareSize + minGapBetweenSquares; // Total width needed per square slot

            // --- Input Handling ---
            const keys = { ArrowLeft: false, ArrowRight: false };
            let isTouching = false;
            let touchX = 0;

            window.addEventListener('keydown', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = true; });
            window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });

            function handleTouchMove(clientX) {
                let targetRectCenterX = clientX;
                let newRectX = targetRectCenterX - playerRect.width / 2;
                newRectX = Math.max(0, Math.min(newRectX, canvasWidth - playerRect.width)); // Clamp within bounds
                playerRect.x = newRectX;
            }

            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length > 0) {
                    isTouching = true;
                    touchX = e.touches[0].clientX;
                    handleTouchMove(touchX);
                }
            }, { passive: false });

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isTouching && e.touches.length > 0) {
                    touchX = e.touches[0].clientX;
                    handleTouchMove(touchX);
                }
            }, { passive: false });

            canvas.addEventListener('touchend', () => { isTouching = false; });
            canvas.addEventListener('touchcancel', () => { isTouching = false; });

            // --- Helper Functions ---
            function getRandomInt(min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            }

             // Function to shuffle an array (Fisher-Yates algorithm)
            function shuffleArray(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]]; // Swap elements
                }
            }


            // --- Game Logic Functions ---

            function generateNewProblem() {
                currentProblem.factor1 = getRandomInt(1, 9);
                currentProblem.factor2 = getRandomInt(1, 9);
                correctAnswer = currentProblem.factor1 * currentProblem.factor2;
                playerRect.color = getRandomPastelColor();
            }

            function generateFallingSquares() {
                fallingSquares.length = 0;
                let numberOfSquares = 5 + Math.floor(level / 2);
                const levelBaseSpeed = baseFallSpeed + (level - 1) * speedIncrement;
                const correctSquareIndex = getRandomInt(0, numberOfSquares - 1);
                const incorrectAnswers = new Set();

                while (incorrectAnswers.size < numberOfSquares - 1) {
                    let incorrect;
                    if (Math.random() < 0.6 && correctAnswer > 1) {
                        incorrect = correctAnswer + getRandomInt(-Math.min(correctAnswer - 1, 5), 5);
                        if (incorrect === correctAnswer) incorrect++;
                    } else {
                        incorrect = getRandomInt(1, 9) * getRandomInt(1, 9);
                    }
                    if (incorrect !== correctAnswer && incorrect > 0 && !incorrectAnswers.has(incorrect)) {
                        incorrectAnswers.add(incorrect);
                    }
                }
                const incorrectArray = Array.from(incorrectAnswers);


                // UPDATE 1 & 2: Implement Slot-based Placement
                const maxNumberOfSlots = Math.floor(canvasWidth / requiredSlotWidth);

                // Ensure we don't try to place more squares than available slots
                if (numberOfSquares > maxNumberOfSlots) {
                    // console.warn(`Reducing number of squares from ${numberOfSquares} to ${maxNumberOfSlots} due to screen width.`);
                    numberOfSquares = maxNumberOfSlots;
                    // Make sure the correct answer is still included if squares were reduced
                    if (correctSquareIndex >= numberOfSquares) {
                        // Simple fix: swap the last incorrect number with the correct one
                        // (More robust would be to regenerate incorrect numbers if needed)
                        if (incorrectArray.length > 0) {
                           incorrectArray[incorrectArray.length - 1] = correctAnswer;
                        } else {
                            // Extremely unlikely edge case: only 1 square possible, must be correct
                             numberOfSquares = 1;
                             // Correct answer is already set
                        }
                    }
                }

                if (numberOfSquares <= 0) return; // Should not happen with calculation, but safety check

                const slotIndices = Array.from({ length: maxNumberOfSlots }, (_, k) => k);
                shuffleArray(slotIndices);
                const chosenSlots = slotIndices.slice(0, numberOfSquares);

                // Calculate offset to center the block of slots
                const totalWidthUsed = maxNumberOfSlots * requiredSlotWidth;
                const offsetLeft = Math.max(0, (canvasWidth - totalWidthUsed) / 2); // Ensure offset is not negative


                for (let i = 0; i < numberOfSquares; i++) {
                    const isCorrect = (i === correctSquareIndex && numberOfSquares > incorrectArray.length) || // Handle the normal case
                                      (i === numberOfSquares -1 && numberOfSquares === incorrectArray.length + 1 && incorrectArray.length < 5 + Math.floor(level / 2)); // Handle case where correct answer was potentially moved to the end

                    // Use the pre-shuffled, unique slot index
                    const slotIndex = chosenSlots[i];

                    // Calculate the center of the slot, then the square's top-left X
                    const slotCenterX = offsetLeft + (slotIndex * requiredSlotWidth) + (requiredSlotWidth / 2);
                    const startX = slotCenterX - squareSize / 2;

                    // Ensure startX is within bounds (can happen with rounding or narrow screens)
                    const clampedStartX = Math.max(0, Math.min(startX, canvasWidth - squareSize));

                    const speedVariation = 0.85 + Math.random() * 0.30;
                    const individualSpeed = Math.max(0.5, levelBaseSpeed * speedVariation);

                    fallingSquares.push({
                        x: clampedStartX, // Use calculated X based on slot
                        y: -(Math.random() * canvasHeight * 0.4 + squareSize * 1.5), // Slightly more staggered start Y
                        size: squareSize,
                        number: isCorrect ? correctAnswer : incorrectArray.pop(),
                        color: getRandomPastelColor(),
                        speed: individualSpeed,
                        isCorrect: isCorrect
                    });
                }
                 // Ensure incorrectArray is empty if logic was complex
                incorrectArray.length = 0;
            }


            function startNewRound() {
                gameActive = false;
                generateNewProblem();
                playerRect.width = playerRect.baseWidth;
                playerRect.height = playerRect.baseHeight;
                generateFallingSquares(); // Generates squares with new spacing logic
                updateUI();
                setTimeout(() => { gameActive = true; }, 300);
            }

            function restartCurrentAttempt() {
                 gameActive = false;
                 playerRect.width = playerRect.baseWidth;
                 playerRect.height = playerRect.baseHeight;
                 generateFallingSquares(); // Regenerate squares for SAME problem with spacing
                 updateUI();
                 setTimeout(() => { gameActive = true; }, 300);
            }

            function updateUI() {
                scoreElement.textContent = `Score: ${score}`;
                levelElement.textContent = `Level: ${level}`;
            }

            // --- Drawing Functions ---

            function drawBottomRectangle() {
                ctx.fillStyle = playerRect.color;
                ctx.fillRect(playerRect.x, playerRect.y, playerRect.width, playerRect.height);
                ctx.strokeStyle = playerRect.gridLineColor;
                ctx.lineWidth = playerRect.gridLineWidth * 2;
                ctx.strokeRect(playerRect.x, playerRect.y, playerRect.width, playerRect.height);

                const cellWidth = playerRect.width / currentProblem.factor1;
                const cellHeight = playerRect.height / currentProblem.factor2;

                ctx.lineWidth = playerRect.gridLineWidth;
                ctx.strokeStyle = playerRect.gridLineColor;

                for (let i = 1; i < currentProblem.factor1; i++) {
                    ctx.beginPath();
                    ctx.moveTo(playerRect.x + i * cellWidth, playerRect.y);
                    ctx.lineTo(playerRect.x + i * cellWidth, playerRect.y + playerRect.height);
                    ctx.stroke();
                }
                for (let j = 1; j < currentProblem.factor2; j++) {
                    ctx.beginPath();
                    ctx.moveTo(playerRect.x, playerRect.y + j * cellHeight);
                    ctx.lineTo(playerRect.x + playerRect.width, playerRect.y + j * cellHeight);
                    ctx.stroke();
                }

                ctx.fillStyle = playerRect.labelColor;
                ctx.font = playerRect.labelFont;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(`${currentProblem.factor1}`, playerRect.x + playerRect.width - cellWidth / 2, playerRect.y + playerRect.height + 5);

                ctx.textAlign = 'left';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${currentProblem.factor2}`, playerRect.x + playerRect.width + 5, playerRect.y + playerRect.height - cellHeight / 2);

                if (feedbackTimer > 0) {
                    ctx.globalAlpha = feedbackTimer / 30;
                    ctx.fillStyle = feedbackType === 'correct' ? 'rgba(255, 255, 255, 0.7)' : 'rgba(255, 0, 0, 0.7)';
                    ctx.fillRect(playerRect.x, playerRect.y, playerRect.width, playerRect.height);
                    ctx.globalAlpha = 1.0;
                }
            }

            function drawFallingSquares() {
                fallingSquares.forEach(square => {
                    ctx.fillStyle = square.color;
                    ctx.fillRect(square.x, square.y, square.size, square.size);
                    ctx.fillStyle = '#333';
                    ctx.font = `bold ${square.size * 0.45}px Arial`;
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(square.number, square.x + square.size / 2, square.y + square.size / 2 + 2);
                });
            }

             // --- Update & Collision ---

            function handlePlayerMovement() {
                if (!isTouching) {
                    playerRect.dx = 0;
                    if (keys.ArrowLeft) playerRect.dx = -playerRect.speed;
                    if (keys.ArrowRight) playerRect.dx = playerRect.speed;
                    let newX = playerRect.x + playerRect.dx;
                    newX = Math.max(0, Math.min(newX, canvasWidth - playerRect.width)); // Clamp
                    playerRect.x = newX;
                } else {
                    playerRect.dx = 0;
                }
                // Touch movement is handled directly in handleTouchMove
            }

            function updateFallingSquares() {
                if (!gameActive) return;
                for (let i = fallingSquares.length - 1; i >= 0; i--) {
                    const square = fallingSquares[i];
                    square.y += square.speed;
                    if (square.y > canvasHeight) {
                        fallingSquares.splice(i, 1);
                    }
                }
            }

            function checkCollisions() {
                if (!gameActive) return;
                for (let i = fallingSquares.length - 1; i >= 0; i--) {
                    if (!fallingSquares[i]) continue;
                    const square = fallingSquares[i];
                    const squareBottom = square.y + square.size;
                    const squareTop = square.y;
                    const squareLeft = square.x;
                    const squareRight = square.x + square.size;
                    const rectTop = playerRect.y;
                    const rectLeft = playerRect.x;
                    const rectRight = playerRect.x + playerRect.width;
                    const collisionTolerance = square.speed > 0 ? square.speed + 2 : 3;

                    if (squareBottom >= rectTop && squareTop < rectTop + collisionTolerance &&
                        squareRight > rectLeft && squareLeft < rectRight)
                    {
                        if (square.isCorrect) {
                            score++;
                            if (score > 0 && score % 5 === 0 && level < maxLevel) { level++; }
                            feedbackType = 'correct';
                            feedbackTimer = 30;
                            startNewRound();
                            return; // Exit collision check immediately after a catch
                        } else {
                            feedbackType = 'incorrect';
                            feedbackTimer = 30;
                            restartCurrentAttempt();
                            return; // Exit collision check immediately after a catch
                        }
                    }
                }
            }

            // --- Game Loop ---
            function gameLoop(timestamp) {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                handlePlayerMovement();
                updateFallingSquares();
                checkCollisions();
                drawBottomRectangle();
                drawFallingSquares();
                if (feedbackTimer > 0) {
                    feedbackTimer--;
                    if (feedbackTimer <= 0) { feedbackType = null; }
                }
                requestAnimationFrame(gameLoop);
            }

            // --- Initialization ---
            function init() {
                playerRect.width = playerRect.baseWidth;
                playerRect.height = playerRect.baseHeight;
                playerRect.y = canvasHeight - playerRect.baseHeight - 40;
                playerRect.x = canvasWidth / 2 - playerRect.baseWidth / 2;

                window.addEventListener('resize', () => {
                     canvasWidth = window.innerWidth;
                     canvasHeight = window.innerHeight;
                     canvas.width = canvasWidth;
                     canvas.height = canvasHeight;
                     playerRect.y = canvasHeight - playerRect.baseHeight - 40;
                     playerRect.x = canvasWidth / 2 - playerRect.baseWidth / 2;
                     // Restart attempt ensures squares are regenerated respecting new width/slot constraints
                     restartCurrentAttempt();
                });

                startNewRound();
                updateUI();
                gameLoop();
            }

            // --- Start the game ---
            init();
        });
    </script>
</body>
</html>
