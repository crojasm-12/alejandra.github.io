<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>Multiplication Catch Game</title>
    <style>
        /* Basic Reset & No Scrollbars */
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            overflow: hidden; font-family: 'Arial', sans-serif;
            overscroll-behavior: none; background-color: #0a0a1a;
        }

        /* Space Background */
        body {
            background-image:
                radial-gradient(circle at 20% 30%, rgba(173, 216, 230, 0.1) 0%, transparent 30%),
                radial-gradient(circle at 80% 70%, rgba(221, 160, 221, 0.1) 0%, transparent 30%),
                radial-gradient(circle at 50% 50%, rgba(255, 255, 255, 0.05) 0%, transparent 5%),
                radial-gradient(circle at 10% 10%, white 0.5px, transparent 1px),
                radial-gradient(circle at 50% 20%, white 0.5px, transparent 1px),
                radial-gradient(circle at 90% 30%, white 0.5px, transparent 1px),
                radial-gradient(circle at 30% 50%, white 0.5px, transparent 1px),
                radial-gradient(circle at 70% 60%, white 0.5px, transparent 1px),
                radial-gradient(circle at 15% 80%, white 0.5px, transparent 1px),
                radial-gradient(circle at 60% 90%, white 0.5px, transparent 1px),
                radial-gradient(circle at 85% 55%, white 0.5px, transparent 1px);
            background-size: cover; background-attachment: fixed;
        }

        /* Score, Failures, and Level Display */
        #scoreDisplay, #failuresDisplay, #levelDisplay {
            position: absolute; padding: 10px 15px; border-radius: 8px;
            font-size: 1.4em; /* Slightly smaller to fit failures */
            font-weight: bold; color: #333;
            text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.5); z-index: 10;
            user-select: none; -webkit-user-select: none;
            -moz-user-select: none; -ms-user-select: none;
        }

        #scoreDisplay {
            top: 10px; left: 10px; background-color: #A0E7E5; /* Cyan */
        }

        /* UPDATE 3: Failures Display Styling */
        #failuresDisplay {
            top: 55px; /* Position below score */
            left: 10px; background-color: #FFDAC1; /* Peach */
        }

        #levelDisplay {
            top: 10px; right: 10px; background-color: #FFAEBC; /* Pink */
        }

        /* Canvas Styling */
        #gameCanvas {
            display: block; position: absolute; top: 0; left: 0;
            z-index: 1; background-color: transparent;
        }
    </style>
</head>
<body>
    <!-- UI Elements -->
    <div id="scoreDisplay">Score: 0</div>
    <!-- UPDATE 3: Added Failures Display -->
    <div id="failuresDisplay">Fallas: 0</div>
    <div id="levelDisplay">Level: 1</div>

    <!-- Game Canvas -->
    <canvas id="gameCanvas"></canvas>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- Canvas Setup ---
            const canvas = document.getElementById('gameCanvas');
            const ctx = canvas.getContext('2d');
            let canvasWidth = window.innerWidth;
            let canvasHeight = window.innerHeight;
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;

            // --- UI Elements ---
            const scoreElement = document.getElementById('scoreDisplay');
            const failuresElement = document.getElementById('failuresDisplay'); // UPDATE 3
            const levelElement = document.getElementById('levelDisplay');

            // --- Game State ---
            let score = 0;
            let failures = 0; // UPDATE 3: Failure counter
            let level = 1;
            const maxLevel = 12; // UPDATE 1: Increased max level
            let currentProblem = { factor1: 1, factor2: 1 };
            let correctAnswer = 1;
            let gameActive = true;
            let feedbackTimer = 0;
            let feedbackType = null;
            let fullscreenRequested = false;

            // UPDATE 2: Explosion animation state
            let explosionActive = false;
            let explosionProgress = 0;
            const explosionDuration = 40; // Frames for explosion/flash (slightly longer)
            const explosionDistance = 30; // Max distance lines move

            // --- Pastel Colors ---
            const pastelColors = ['#A0E7E5', '#B4F8C8', '#FBE7C6', '#FFAEBC', '#FFDAC1', '#CDB4DB', '#FFFACD', '#ADD8E6'];
            function getRandomPastelColor() { return pastelColors[Math.floor(Math.random() * pastelColors.length)]; }
            const failureColor = '#FF5733'; // UPDATE 4: Distinct Red/Orange for failure square

            // --- Player Controlled Rectangle ---
            const originalBaseWidth = 150; const originalBaseHeight = 100;
            const playerRect = {
                baseWidth: originalBaseWidth * 0.8, baseHeight: originalBaseHeight * 0.8,
                x: canvasWidth / 2 - (originalBaseWidth * 0.8) / 2,
                y: canvasHeight - (originalBaseHeight * 0.8) - 40,
                width: originalBaseWidth * 0.8, height: originalBaseHeight * 0.8,
                speed: 8, dx: 0, color: getRandomPastelColor(),
                gridLineWidth: 1, gridLineColor: 'rgba(50, 50, 50, 0.5)',
                labelFont: 'bold 14px Arial', labelColor: 'white'
            };

            // --- Falling Squares ---
            const fallingSquares = []; const squareSize = 60;
            const baseFallSpeed = 1; const speedIncrement = 0.3;
            const minGapBetweenSquares = playerRect.baseWidth;
            const requiredSlotWidth = squareSize + minGapBetweenSquares;

             // --- Helper Functions ---
            function getRandomInt(min, max) { return Math.floor(Math.random() * (max - min + 1)) + min; }
            function shuffleArray(array) { for (let i = array.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [array[i], array[j]] = [array[j], array[i]]; } }
            function isMobileDevice() { return /Mobi|Android|iPhone|iPad|iPod|Windows Phone/i.test(navigator.userAgent); }
            function goFullScreen() {
                const element = document.documentElement;
                if (element.requestFullscreen) element.requestFullscreen();
                else if (element.mozRequestFullScreen) element.mozRequestFullScreen();
                else if (element.webkitRequestFullscreen) element.webkitRequestFullscreen();
                else if (element.msRequestFullscreen) element.msRequestFullscreen();
                fullscreenRequested = true;
            }

            // --- Input Handling ---
            const keys = { ArrowLeft: false, ArrowRight: false };
            let isTouching = false; let touchX = 0;
            window.addEventListener('keydown', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = true; });
            window.addEventListener('keyup', (e) => { if (keys.hasOwnProperty(e.key)) keys[e.key] = false; });
            function handleTouchMove(clientX) {
                let newRectX = clientX - playerRect.width / 2;
                playerRect.x = Math.max(0, Math.min(newRectX, canvasWidth - playerRect.width));
            }
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (isMobileDevice() && !fullscreenRequested) { goFullScreen(); }
                if (e.touches.length > 0) { isTouching = true; touchX = e.touches[0].clientX; handleTouchMove(touchX); }
            }, { passive: false });
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (isTouching && e.touches.length > 0) { touchX = e.touches[0].clientX; handleTouchMove(touchX); }
            }, { passive: false });
            canvas.addEventListener('touchend', () => { isTouching = false; });
            canvas.addEventListener('touchcancel', () => { isTouching = false; });

            // --- Game Logic Functions ---
            function generateNewProblem() {
                currentProblem.factor1 = getRandomInt(1, 9); currentProblem.factor2 = getRandomInt(1, 9);
                correctAnswer = currentProblem.factor1 * currentProblem.factor2;
                playerRect.color = getRandomPastelColor();
            }

            function generateFallingSquares() {
                fallingSquares.length = 0;
                let numberOfSquares = 5 + Math.floor(level / 2);
                const levelBaseSpeed = baseFallSpeed + (level - 1) * speedIncrement;
                let correctSquareIndex = getRandomInt(0, numberOfSquares - 1);
                const incorrectAnswers = new Set();

                while (incorrectAnswers.size < numberOfSquares - 1) {
                    let incorrect;
                    if (Math.random() < 0.6 && correctAnswer > 1) {
                        incorrect = correctAnswer + getRandomInt(-Math.min(correctAnswer - 1, 5), 5);
                        if (incorrect === correctAnswer) incorrect++;
                    } else { incorrect = getRandomInt(1, 9) * getRandomInt(1, 9); }
                    if (incorrect !== correctAnswer && incorrect > 0 && !incorrectAnswers.has(incorrect)) { incorrectAnswers.add(incorrect); }
                }
                const incorrectArray = Array.from(incorrectAnswers);

                const maxNumberOfSlots = Math.floor(canvasWidth / requiredSlotWidth);
                let actualNumberOfSquares = numberOfSquares;

                if (numberOfSquares > maxNumberOfSlots) {
                    actualNumberOfSquares = maxNumberOfSlots;
                    if (correctSquareIndex >= actualNumberOfSquares) {
                        if (incorrectArray.length >= actualNumberOfSquares && actualNumberOfSquares > 0) {
                            incorrectArray[actualNumberOfSquares - 1] = correctAnswer;
                            correctSquareIndex = actualNumberOfSquares - 1;
                        } else if (actualNumberOfSquares === 1) {
                            correctSquareIndex = 0; // Only one slot, must be correct
                        }
                    }
                }
                if (actualNumberOfSquares <= 0) return;

                const slotIndices = Array.from({ length: maxNumberOfSlots }, (_, k) => k);
                shuffleArray(slotIndices);
                const chosenSlots = slotIndices.slice(0, actualNumberOfSquares);

                const totalWidthUsed = maxNumberOfSlots * requiredSlotWidth;
                const offsetLeft = Math.max(0, (canvasWidth - totalWidthUsed) / 2);

                for (let i = 0; i < actualNumberOfSquares; i++) {
                    const isCorrect = (i === correctSquareIndex);
                    const number = isCorrect ? correctAnswer : incorrectArray.pop();
                    if (typeof number === 'undefined' && isCorrect) {
                        // Safety check: if incorrect array was unexpectedly empty but we need correct
                        // This shouldn't happen with the revised logic, but good to have
                        number = correctAnswer;
                    } else if (typeof number === 'undefined') continue; // Skip if no number available

                    const slotIndex = chosenSlots[i];
                    const slotCenterX = offsetLeft + (slotIndex * requiredSlotWidth) + (requiredSlotWidth / 2);
                    const startX = slotCenterX - squareSize / 2;
                    const clampedStartX = Math.max(0, Math.min(startX, canvasWidth - squareSize));

                    const speedVariation = 0.85 + Math.random() * 0.30;
                    const individualSpeed = Math.max(0.5, levelBaseSpeed * speedVariation);

                    fallingSquares.push({
                        x: clampedStartX, y: -(Math.random() * canvasHeight * 0.4 + squareSize * 1.5),
                        size: squareSize, number: number, color: getRandomPastelColor(),
                        speed: individualSpeed, isCorrect: isCorrect
                    });
                }
                incorrectArray.length = 0;
            }

            function startNewRound() {
                gameActive = true; // Ensure game is active for new round
                explosionActive = false; // Ensure explosion is off
                feedbackType = null; // Reset feedback
                feedbackTimer = 0;
                generateNewProblem();
                playerRect.width = playerRect.baseWidth; playerRect.height = playerRect.baseHeight;
                generateFallingSquares();
                updateUI();
                // No timeout needed now as gameActive is true
            }

            // UPDATE 2 & 3: Renamed and modified restart logic
            function restartAttemptInternal() {
                gameActive = true; // Re-enable game logic AFTER explosion
                explosionActive = false; // Ensure explosion state is reset
                // Regenerate squares for the SAME problem
                playerRect.width = playerRect.baseWidth;
                playerRect.height = playerRect.baseHeight;
                generateFallingSquares();
                updateUI(); // Update UI (score/level unchanged, failures updated earlier)
            }

            // UPDATE 2 & 3: Function to handle the sequence of events on incorrect catch
            function triggerIncorrectCatchSequence(collidedSquare) {
                gameActive = false; // PAUSE game logic immediately
                failures++; // Increment failure count
                updateUI(); // Update display immediately

                 // UPDATE 4: Make the collided square red
                if (collidedSquare) {
                    collidedSquare.color = failureColor;
                }

                feedbackType = 'incorrect'; // For red flash on catcher
                feedbackTimer = explosionDuration; // Sync flash timer with explosion
                explosionActive = true; // START explosion animation
                explosionProgress = 0;
                // restartAttemptInternal() will be called when explosion finishes in gameLoop
            }

            function updateUI() {
                scoreElement.textContent = `Score: ${score}`;
                failuresElement.textContent = `Fallas: ${failures}`; // UPDATE 3
                levelElement.textContent = `Level: ${level}`;
            }

            // --- Drawing Functions ---
            function drawBottomRectangle() {
                const rectX = playerRect.x;
                const rectY = playerRect.y;
                const rectW = playerRect.width;
                const rectH = playerRect.height;

                // Draw main rectangle background
                ctx.fillStyle = playerRect.color;
                ctx.fillRect(rectX, rectY, rectW, rectH);
                ctx.strokeStyle = playerRect.gridLineColor;
                ctx.lineWidth = playerRect.gridLineWidth * 2;
                ctx.strokeRect(rectX, rectY, rectW, rectH);

                // Calculate grid cell dimensions
                const cellWidth = rectW / currentProblem.factor1;
                const cellHeight = rectH / currentProblem.factor2;

                ctx.lineWidth = playerRect.gridLineWidth;
                ctx.strokeStyle = playerRect.gridLineColor;

                // Calculate offset for explosion
                let currentOffset = 0;
                if (explosionActive) {
                    // Use easing function for smoother explosion (e.g., easeOutQuad)
                    const t = explosionProgress / explosionDuration;
                    currentOffset = explosionDistance * t * (2 - t); // Ease out quadratic
                    // Or simpler linear: currentOffset = (explosionProgress / explosionDuration) * explosionDistance;
                }

                // Draw vertical grid lines (potentially exploded)
                for (let i = 1; i < currentProblem.factor1; i++) {
                    const lineX = rectX + i * cellWidth;
                    const startY = rectY - (explosionActive ? currentOffset : 0); // Move start point up
                    const endY = rectY + rectH + (explosionActive ? currentOffset : 0); // Move end point down
                    // Optional: Add horizontal shift based on position relative to center
                    const centerX = rectX + rectW / 2;
                    const horizontalShift = explosionActive ? (lineX < centerX ? -currentOffset : currentOffset) * 0.5 : 0; // Weaker horizontal shift

                    ctx.beginPath();
                    ctx.moveTo(lineX + horizontalShift, startY);
                    ctx.lineTo(lineX + horizontalShift, endY);
                    ctx.stroke();
                }

                // Draw horizontal grid lines (potentially exploded)
                for (let j = 1; j < currentProblem.factor2; j++) {
                    const lineY = rectY + j * cellHeight;
                    const startX = rectX - (explosionActive ? currentOffset : 0); // Move start point left
                    const endX = rectX + rectW + (explosionActive ? currentOffset : 0); // Move end point right
                    // Optional: Add vertical shift based on position relative to center
                    const centerY = rectY + rectH / 2;
                    const verticalShift = explosionActive ? (lineY < centerY ? -currentOffset : currentOffset) * 0.5 : 0; // Weaker vertical shift

                    ctx.beginPath();
                    ctx.moveTo(startX, lineY + verticalShift);
                    ctx.lineTo(endX, lineY + verticalShift);
                    ctx.stroke();
                }

                // Draw grid dimension labels (always drawn normally)
                ctx.fillStyle = playerRect.labelColor; ctx.font = playerRect.labelFont;
                ctx.textAlign = 'center'; ctx.textBaseline = 'top';
                ctx.fillText(`${currentProblem.factor1}`, rectX + rectW - cellWidth / 2, rectY + rectH + 5);
                ctx.textAlign = 'left'; ctx.textBaseline = 'middle';
                ctx.fillText(`${currentProblem.factor2}`, rectX + rectW + 5, rectY + rectH - cellHeight / 2);

                // Draw feedback flash on catcher (red during explosion/incorrect)
                if (feedbackTimer > 0 && feedbackType === 'incorrect') {
                    ctx.globalAlpha = (feedbackTimer / explosionDuration) * 0.7; // Fade out flash
                    ctx.fillStyle = 'rgba(255, 0, 0, 0.8)'; // Stronger red flash
                    ctx.fillRect(rectX, rectY, rectW, rectH);
                    ctx.globalAlpha = 1.0;
                } else if (feedbackTimer > 0 && feedbackType === 'correct') { // Correct flash (optional, shorter?)
                     ctx.globalAlpha = (feedbackTimer / 15) * 0.7; // Quick white flash
                     ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
                     ctx.fillRect(rectX, rectY, rectW, rectH);
                     ctx.globalAlpha = 1.0;
                }
            }

            function drawFallingSquares() {
                // Draw only if game is active OR explosion is active (to show the red square)
                 if (!gameActive && !explosionActive) return;

                fallingSquares.forEach(square => {
                    ctx.fillStyle = square.color; // Color might be red if it caused failure
                    ctx.fillRect(square.x, square.y, square.size, square.size);
                    ctx.fillStyle = '#333'; ctx.font = `bold ${square.size * 0.45}px Arial`;
                    ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
                    ctx.fillText(square.number, square.x + square.size / 2, square.y + square.size / 2 + 2);
                });
            }

             // --- Update & Collision ---
            function handlePlayerMovement() {
                 // Allow movement only if game is active (not during explosion)
                if (!gameActive) return;

                if (!isTouching) {
                    playerRect.dx = 0;
                    if (keys.ArrowLeft) playerRect.dx = -playerRect.speed;
                    if (keys.ArrowRight) playerRect.dx = playerRect.speed;
                    let newX = playerRect.x + playerRect.dx;
                    playerRect.x = Math.max(0, Math.min(newX, canvasWidth - playerRect.width));
                } else { playerRect.dx = 0; }
            }

            function updateFallingSquares() {
                // Update positions only if game is active
                if (!gameActive) return;
                for (let i = fallingSquares.length - 1; i >= 0; i--) {
                    const square = fallingSquares[i]; square.y += square.speed;
                    if (square.y > canvasHeight) { fallingSquares.splice(i, 1); }
                }
            }

            function checkCollisions() {
                 // Check collisions only if game is active
                if (!gameActive) return;

                for (let i = fallingSquares.length - 1; i >= 0; i--) {
                    if (!fallingSquares[i]) continue;
                    const square = fallingSquares[i]; const squareBottom = square.y + square.size;
                    const squareTop = square.y; const squareLeft = square.x;
                    const squareRight = square.x + square.size; const rectTop = playerRect.y;
                    const rectLeft = playerRect.x; const rectRight = playerRect.x + playerRect.width;
                    const collisionTolerance = square.speed > 0 ? square.speed + 2 : 3;

                    if (squareBottom >= rectTop && squareTop < rectTop + collisionTolerance && squareRight > rectLeft && squareLeft < rectRight) {
                        if (square.isCorrect) {
                            score++;
                            if (score > 0 && score % 5 === 0 && level < maxLevel) { level++; } // Check against new maxLevel
                            feedbackType = 'correct'; feedbackTimer = 15; // Shorter correct flash?
                            startNewRound(); // Start next round immediately
                            return;
                        } else {
                            // Incorrect Catch - Trigger the sequence
                            triggerIncorrectCatchSequence(square); // Pass the collided square
                            return; // Stop checking collisions
                        }
                    }
                }
            }

            // --- Game Loop ---
            function gameLoop(timestamp) {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);

                handlePlayerMovement(); // Moves player if gameActive
                updateFallingSquares(); // Moves squares if gameActive
                checkCollisions();      // Checks collisions if gameActive

                // UPDATE 2: Handle Explosion Animation
                if (explosionActive) {
                    explosionProgress++;
                    if (explosionProgress >= explosionDuration) {
                        // Explosion finished, restart the attempt internally
                        restartAttemptInternal();
                        // explosionActive is set to false inside restartAttemptInternal
                    }
                }

                 // Update feedback timer for flashes (runs regardless of gameActive)
                 if (feedbackTimer > 0) {
                    feedbackTimer--;
                     if (feedbackTimer <= 0 && feedbackType === 'correct') { // Clear correct feedback type
                          feedbackType = null;
                     }
                      // Incorrect feedback type cleared implicitly by restart logic/explosion end
                 }


                // Draw elements (always draw catcher, draw squares if game active OR explosion active)
                drawBottomRectangle();
                drawFallingSquares();

                requestAnimationFrame(gameLoop);
            }

            // --- Initialization ---
            function init() {
                playerRect.width = playerRect.baseWidth; playerRect.height = playerRect.baseHeight;
                playerRect.y = canvasHeight - playerRect.baseHeight - 40;
                playerRect.x = canvasWidth / 2 - playerRect.baseWidth / 2;

                window.addEventListener('resize', () => {
                     canvasWidth = window.innerWidth; canvasHeight = window.innerHeight;
                     canvas.width = canvasWidth; canvas.height = canvasHeight;
                     playerRect.y = canvasHeight - playerRect.baseHeight - 40;
                     playerRect.x = canvasWidth / 2 - playerRect.baseWidth / 2;
                     // If resizing during explosion, it might look weird, but restarting fixes it
                     restartAttemptInternal(); // Use internal to reset layout properly
                });

                startNewRound(); // Start first round
                // updateUI(); // updateUI is called within startNewRound
                gameLoop();
            }

            // --- Start the game ---
            init();
        });
    </script>
</body>
</html>
